trigger: none
pr:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'

variables:
- group: pythonrest-cli

jobs:
- job: ValidateCommitMessage
  displayName: Validate commit message
  pool:
    vmImage: ubuntu-latest
  steps:
  - checkout: self
  - script: |
      # Ensure we have full commit history in the CI environment
      git fetch --all --unshallow

      # Find the last non-merge commit before the merge commit (PR source commit)
      last_commit_message=$(git log -1 --pretty=%s $(git rev-list --no-merges -n 1 HEAD))

      if [[ $last_commit_message =~ version\ ?[0-9]+\.[0-9]+\.[0-9]+ ]]; then
        echo "Commit message contains a valid version format: $last_commit_message"
      else
        echo "Error: The commit message does not contain a valid version format (versionX.X.X)."
        echo "Last commit message: $last_commit_message"
        exit 1
      fi
    displayName: "Check commit message format"

- job: PublishToPyPi
  displayName: '3. Publish to PyPI'
  dependsOn: CreateGitHubRelease # Depends on the GitHub Release job
  pool:
    vmImage: ubuntu-latest
  variables:
    # Map the output variable from ExtractVersion job
    LOCAL_SETUP_VERSION: $[ dependencies.ExtractVersion.outputs['VersionExtractionStep.packageVersion'] ]
  steps:
  - checkout: self # Need to checkout again to have setup.py and pythonrest.py (which were modified in ExtractVersion)
                  # If ExtractVersion published artifacts, this job could download them instead.
                  # For simplicity, checking out again is fine if modifications are idempotent or source is clean.
                  # The files modified (setup.py, pythonrest.py) are part of the repo, so checkout brings them.
                  # We need to ensure the file modifications from ExtractVersion are present.
                  # A better way would be to pass setup.py and pythonrest.py as artifacts.
                  # For now, re-running the sed commands to ensure file state if checkout is clean.
  - script: |
      echo "Ensuring setup.py and pythonrest.py are updated with version $(LOCAL_SETUP_VERSION)..."
      sed -i "s/version='[0-9]\+\.[0-9]\+\.[0-9]\+'$/version='$(LOCAL_SETUP_VERSION)'/" ./setup.py
      sed -i "s/pythonrest_version = \"[0-9]\+\.[0-9]\+\.[0-9]\+\"/pythonrest_version = \"$(LOCAL_SETUP_VERSION)\"/" ./pythonrest.py

      echo "Updated setup.py and pythonrest.py version to $(LOCAL_SETUP_VERSION) for PyPI job."
      grep "version=" ./setup.py
      grep "pythonrest_version" ./pythonrest.py

      # The rest of the original PyPI publishing script
      latest_version=$(curl -s https://pypi.org/pypi/$(pypi_app_name)/json | jq -r '.info.version' 2>/dev/null || echo "0.0.0")
      echo "Latest version on PyPI: $latest_version"

      # local_version variable is now LOCAL_SETUP_VERSION from the previous job
      echo "Local version for setup.py (from previous job): $(LOCAL_SETUP_VERSION)"

      if [ "$latest_version" != "$(LOCAL_SETUP_VERSION)" ]; then
        echo "Versions are different. Uploading to PyPI."
        pip3 install --upgrade pip
        pip3 install --upgrade packaging twine setuptools wheel
        python3 setup.py sdist bdist_wheel # Build both sdist and wheel
        python3 -m twine upload dist/* --username __token__ --password $(pip_api_key)
      else
        echo "Versions are the same ($(LOCAL_SETUP_VERSION)). Skipping PyPI upload."
      fi
    displayName: 'Check Version and Publish to PyPI'
    env:
      # Map necessary variables from variable group 'pythonrest-cli'
      pypi_app_name: $(pypi_app_name)
      pip_api_key: $(pip_api_key)
